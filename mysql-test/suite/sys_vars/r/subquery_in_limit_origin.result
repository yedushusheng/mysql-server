drop database if exists test123;
Warnings:
Note	1008	Can't drop database 'test123'; database doesn't exist
drop table if exists t1,t2;
Warnings:
Note	1051	Unknown table 'test.t1'
Note	1051	Unknown table 'test.t2'
create database test123;
use test123;
create table t1(a int,b int,c int);
insert into t1 values(1,2,3);
insert into t1 values(2,3,4);
insert into t1 values(3,4,5);
create table t2(a int,b int,c int);
insert into t2 values(1,2,3);
insert into t2 values(2,3,4);
insert into t2 values(3,4,5);
select * from t1 where a in ( select * from (select b from t2 limit 1) as d);
a	b	c
2	3	4
explain format=tree select * from t1 where a in ( select * from (select b from t2 limit 1) as d);
EXPLAIN
-> Inner hash join (t1.a = `<subquery2>`.b)  (cost=2260.23 rows=1000)
    -> Table scan on t1  (cost=227.50 rows=10000)
    -> Hash
        -> Table scan on <subquery2>  (cost=2.51..2.51 rows=1)
            -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit: 1 row(s)  (cost=1127.50 rows=1)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 limit 1, 1) as d);
a	b	c
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 limit 1, 1) as d);
EXPLAIN
-> Nested loop inner join  (cost=3127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 order by b limit 1) as d);
a	b	c
2	3	4
explain format=tree select * from t1 where a in ( select * from (select b from t2 order by b limit 1) as d);
EXPLAIN
-> Inner hash join (t1.a = `<subquery2>`.b)  (cost=2260.23 rows=1000)
    -> Table scan on t1  (cost=227.50 rows=10000)
    -> Hash
        -> Table scan on <subquery2>  (cost=2.51..2.51 rows=1)
            -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit: 1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 order by b limit 1, 1) as d);
a	b	c
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 order by b limit 1, 1) as d);
EXPLAIN
-> Nested loop inner join  (cost=3127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d);
a	b	c
2	3	4
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d);
EXPLAIN
-> Inner hash join (t1.a = `<subquery2>`.b)  (cost=2260.23 rows=1000)
    -> Table scan on t1  (cost=227.50 rows=10000)
    -> Hash
        -> Table scan on <subquery2>  (cost=2.51..2.51 rows=1)
            -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit: 1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d);
a	b	c
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d);
EXPLAIN
-> Nested loop inner join  (cost=3127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) and c > 1;
a	b	c
2	3	4
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) and c > 1;
EXPLAIN
-> Inner hash join (t1.a = `<subquery2>`.b)  (cost=2926.94 rows=333)
    -> Table scan on t1  (cost=827.55 rows=10000)
    -> Hash
        -> Table scan on <subquery2>  (cost=2.51..2.51 rows=1)
            -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit: 1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) and c > 1;
a	b	c
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) and c > 1;
EXPLAIN
-> Nested loop inner join  (cost=2460.80 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d);
a	b	c
2	3	4
explain format=tree select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d);
EXPLAIN
-> Filter: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((t1.a = `<materialized_subquery>`.b))
            -> Limit: 1 row(s)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                    -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                        -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d);
a	b	c
3	4	5
explain format=tree select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d);
EXPLAIN
-> Filter: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((t1.a = `<materialized_subquery>`.b))
            -> Limit: 1 row(s)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                    -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=1130.11..1130.11 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                        -> Table scan on t2  (cost=1127.50 rows=10000)

select a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) from t1 where c > 1;
a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
0
1
0
explain format=tree select a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) from t1 where c > 1;
a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
0
0
1
explain format=tree select a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a, a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) from t1 where c > 1;
a	a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
1	0
2	1
3	0
explain format=tree select a, a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a, a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) from t1 where c > 1;
a	a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
1	0
2	0
3	1
explain format=tree select a, a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
a
1
3
2
explain format=tree select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select b in ( select * from (select b from t2 where a > 0 order by b limit 1) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)	a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
1	0
0	1
0	0
explain format=tree select b in ( select * from (select b from t2 where a > 0 order by b limit 1) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.b = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.b)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #4 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select b in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)	a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
0	0
1	0
0	1
explain format=tree select b in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.b = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.b)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #4 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d))
1
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
EXPLAIN
-> Inner hash join (t1.a = `<subquery4>`.b)  (cost=1794.22 rows=333)
    -> Table scan on t1  (cost=827.55 rows=10000)
    -> Hash
        -> Filter: (`<subquery4>`.b > 1)  (cost=0.00..0.00 rows=1)
            -> Table scan on <subquery4>  (cost=2.51..2.51 rows=1)
                -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                    -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=1130.11..1130.11 rows=1)
                                -> Limit: 1 row(s)  (cost=1127.50 rows=1)
                                    -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=1127.50 rows=10000)
                                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d))
1
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
EXPLAIN
-> Nested loop inner join  (cost=2460.80 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery4> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d))
1
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #6))`
    -> Stream results  (cost=1794.22 rows=333)
        -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=1794.22 rows=333)
            -> Table scan on t1  (cost=827.55 rows=10000)
            -> Hash
                -> Filter: (`<subquery4>`.b > 1)  (cost=0.00..0.00 rows=1)
                    -> Table scan on <subquery4>  (cost=2.51..2.51 rows=1)
                        -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                                -> Table scan on d  (cost=2.51..2.51 rows=1)
                                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                                        -> Limit: 1 row(s)  (cost=1127.50 rows=1)
                                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=1127.50 rows=10000)
                                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d))
1
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #6))`
    -> Stream results  (cost=2794.23 rows=667)
        -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=2794.23 rows=667)
            -> Table scan on t1  (cost=827.56 rows=10000)
            -> Hash
                -> Filter: (`<subquery4>`.b > 1)  (cost=565.11..0.00 rows=2)
                    -> Table scan on <subquery4>  (cost=2.51..2.51 rows=1)
                        -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                                -> Table scan on d  (cost=2.51..2.51 rows=1)
                                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) having (a in ( select * from (select b from t2 limit 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
a	(a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d))
2	1
explain format=tree select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)) having (a in ( select * from (select b from t2 limit 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #8))`
    -> Filter: <in_optimizer>(t1.a,t1.a in (select #6))
        -> Stream results  (cost=1794.22 rows=333)
            -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=1794.22 rows=333)
                -> Table scan on t1  (cost=827.55 rows=10000)
                -> Hash
                    -> Filter: (`<subquery4>`.b > 1)  (cost=0.00..0.00 rows=1)
                        -> Table scan on <subquery4>  (cost=2.51..2.51 rows=1)
                            -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                                -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                                            -> Limit: 1 row(s)  (cost=1127.50 rows=1)
                                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=1127.50 rows=10000)
                                                    -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Filter: ((t1.a = `<materialized_subquery>`.b))
                -> Limit: 1 row(s)
                    -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                        -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #8 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) having (a in ( select * from (select b from t2 limit 1, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
a	(a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d))
3	1
explain format=tree select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)) having (a in ( select * from (select b from t2 limit 1, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #8))`
    -> Filter: <in_optimizer>(t1.a,t1.a in (select #6))
        -> Stream results  (cost=2794.23 rows=667)
            -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=2794.23 rows=667)
                -> Table scan on t1  (cost=827.56 rows=10000)
                -> Hash
                    -> Filter: (`<subquery4>`.b > 1)  (cost=565.11..0.00 rows=2)
                        -> Table scan on <subquery4>  (cost=2.51..2.51 rows=1)
                            -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                                -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                                    -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Filter: ((t1.a = `<materialized_subquery>`.b))
                -> Limit: 1 row(s)
                    -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                            -> Table scan on d  (cost=2.51..2.51 rows=1)
                                -> Materialize  (cost=1130.11..1130.11 rows=1)
                                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #8 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 limit 2) as d);
a	b	c
2	3	4
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 limit 2) as d);
EXPLAIN
-> Nested loop inner join  (cost=4127.50 rows=20000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
            -> Filter: (d.b is not null)  (cost=1128.96..1130.23 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 limit 2, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 limit 2, 1) as d);
EXPLAIN
-> Nested loop inner join  (cost=3127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 order by b limit 2) as d);
a	b	c
2	3	4
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 order by b limit 2) as d);
EXPLAIN
-> Nested loop inner join  (cost=4127.50 rows=20000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
            -> Filter: (d.b is not null)  (cost=1128.96..1130.23 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 order by b limit 2, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 order by b limit 2, 1) as d);
EXPLAIN
-> Nested loop inner join  (cost=3127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d);
a	b	c
2	3	4
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d);
EXPLAIN
-> Nested loop inner join  (cost=4127.50 rows=20000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
            -> Filter: (d.b is not null)  (cost=1128.96..1130.23 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d);
EXPLAIN
-> Nested loop inner join  (cost=3127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) and c > 1;
a	b	c
2	3	4
3	4	5
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) and c > 1;
EXPLAIN
-> Nested loop inner join  (cost=3460.80 rows=20000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
            -> Filter: (d.b is not null)  (cost=1128.96..1130.23 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) and c > 1;
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) and c > 1;
EXPLAIN
-> Nested loop inner join  (cost=2460.80 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery2> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d);
a	b	c
2	3	4
3	4	5
explain format=tree select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d);
EXPLAIN
-> Filter: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((t1.a = `<materialized_subquery>`.b))
            -> Limit: 1 row(s)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                    -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                        -> Table scan on d  (cost=1.26..2.52 rows=2)
                            -> Materialize  (cost=1128.96..1130.23 rows=2)
                                -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d);
a	b	c
explain format=tree select * from t1 where c > 1 having a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d);
EXPLAIN
-> Filter: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Filter: ((t1.a = `<materialized_subquery>`.b))
            -> Limit: 1 row(s)
                -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                    -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=1130.11..1130.11 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                        -> Table scan on t2  (cost=1127.50 rows=10000)

select a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) from t1 where c > 1;
a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
0
1
1
explain format=tree select a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) from t1 where c > 1;
a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
0
0
0
explain format=tree select a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a, a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) from t1 where c > 1;
a	a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
1	0
2	1
3	1
explain format=tree select a, a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a, a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) from t1 where c > 1;
a	a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
1	0
2	0
3	0
explain format=tree select a, a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,t1.a in (select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select b in ( select * from (select b from t2 where a > 0 order by b limit 2) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)	a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
1	0
1	1
0	1
explain format=tree select b in ( select * from (select b from t2 where a > 0 order by b limit 2) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.b = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.b)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #4 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select b in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)	a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
0	0
0	0
1	0
explain format=tree select b in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d), a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.b = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.b)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #4 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d))
1
1
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
EXPLAIN
-> Nested loop inner join  (cost=3460.80 rows=20000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery4> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
            -> Filter: (d.b is not null)  (cost=1128.96..1130.23 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d))
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
EXPLAIN
-> Nested loop inner join  (cost=2460.80 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Single-row index lookup on <subquery4> using <auto_distinct_key> (b=t1.a)
        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d))
1
1
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #6))`
    -> Stream results  (cost=2794.23 rows=667)
        -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=2794.23 rows=667)
            -> Table scan on t1  (cost=827.56 rows=10000)
            -> Hash
                -> Filter: (`<subquery4>`.b > 1)  (cost=565.21..0.00 rows=2)
                    -> Table scan on <subquery4>  (cost=1.26..2.52 rows=2)
                        -> Materialize with deduplication  (cost=1131.69..1132.95 rows=2)
                            -> Filter: (d.b is not null)  (cost=1128.96..1130.23 rows=2)
                                -> Table scan on d  (cost=1.26..2.52 rows=2)
                                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
(a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d))
explain format=tree select (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #6))`
    -> Stream results  (cost=3794.25 rows=1000)
        -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=3794.25 rows=1000)
            -> Table scan on t1  (cost=827.58 rows=10000)
            -> Hash
                -> Filter: (`<subquery4>`.b > 1)  (cost=753.48..0.00 rows=3)
                    -> Table scan on <subquery4>  (cost=2.51..2.51 rows=1)
                        -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                            -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                                -> Table scan on d  (cost=2.51..2.51 rows=1)
                                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) having (a in ( select * from (select b from t2 limit 2) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
a	(a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d))
2	1
3	1
explain format=tree select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)) having (a in ( select * from (select b from t2 limit 2) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #8))`
    -> Filter: <in_optimizer>(t1.a,t1.a in (select #6))
        -> Stream results  (cost=2794.23 rows=667)
            -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=2794.23 rows=667)
                -> Table scan on t1  (cost=827.56 rows=10000)
                -> Hash
                    -> Filter: (`<subquery4>`.b > 1)  (cost=565.21..0.00 rows=2)
                        -> Table scan on <subquery4>  (cost=1.26..2.52 rows=2)
                            -> Materialize with deduplication  (cost=1131.69..1132.95 rows=2)
                                -> Filter: (d.b is not null)  (cost=1128.96..1130.23 rows=2)
                                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                                    -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Filter: ((t1.a = `<materialized_subquery>`.b))
                -> Limit: 1 row(s)
                    -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                        -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                            -> Table scan on d  (cost=1.26..2.52 rows=2)
                                -> Materialize  (cost=1128.96..1130.23 rows=2)
                                    -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #8 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.43..1130.43 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=1128.96..1130.23 rows=2)
                            -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) having (a in ( select * from (select b from t2 limit 2, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
a	(a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d))
explain format=tree select a, (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)) having (a in ( select * from (select b from t2 limit 2, 1) as d)) order by (a in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d));
EXPLAIN
-> Sort: `<in_optimizer>(t1.a,<exists>(select #8))`
    -> Filter: <in_optimizer>(t1.a,t1.a in (select #6))
        -> Stream results  (cost=3794.25 rows=1000)
            -> Inner hash join (t1.a = `<subquery4>`.b)  (cost=3794.25 rows=1000)
                -> Table scan on t1  (cost=827.58 rows=10000)
                -> Hash
                    -> Filter: (`<subquery4>`.b > 1)  (cost=753.48..0.00 rows=3)
                        -> Table scan on <subquery4>  (cost=2.51..2.51 rows=1)
                            -> Materialize with deduplication  (cost=1132.72..1132.72 rows=1)
                                -> Filter: (d.b is not null)  (cost=1130.11..1130.11 rows=1)
                                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                                    -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Filter: ((t1.a = `<materialized_subquery>`.b))
                -> Limit: 1 row(s)
                    -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                        -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                            -> Table scan on d  (cost=2.51..2.51 rows=1)
                                -> Materialize  (cost=1130.11..1130.11 rows=1)
                                    -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #8 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.a = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.a)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.20 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.60..227.60 rows=1)
            -> Limit: 1 row(s)  (cost=227.50 rows=1)
                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.20 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.60..227.60 rows=1)
            -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.20 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.60..227.60 rows=1)
            -> Limit: 1 row(s)  (cost=227.50 rows=1)
                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=227.50 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 1, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 1, 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.20 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.60..227.60 rows=1)
            -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=227.50 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.20 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.20 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) and c > 1;
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) and c > 1;
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) and c > 1;
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) and c > 1;
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d);
a	b	c
explain format=tree select * from t1 where c > 1 having a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d);
EXPLAIN
-> Filter: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
            -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                -> Materialize  (cost=827.63..827.63 rows=1)
                    -> Limit: 1 row(s)  (cost=827.53 rows=1)
                        -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                            -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d));
a	b	c
explain format=tree select * from t1 where c > 1 having a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d));
EXPLAIN
-> Filter: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
            -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                -> Materialize  (cost=827.63..827.63 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                            -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) from t1 where c > 1;
a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
0
0
0
explain format=tree select a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)) from t1 where c > 1;
a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))
0
0
0
explain format=tree select a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) from t1 where c > 1;
a	a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
1	0
2	0
3	0
explain format=tree select a, a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)) from t1 where c > 1;
a	a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))
1	0
2	0
3	0
explain format=tree select a, a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d), a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) from t1 where c > 1;
b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)	a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
1	0
1	0
1	0
explain format=tree select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d), a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select b in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)), a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)) from t1 where c > 1;
b in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))	a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))
0	0
0	0
0	0
explain format=tree select b in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)), a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
(a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d))
explain format=tree select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
(a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)))
explain format=tree select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
(a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d))
explain format=tree select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
            -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
(a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)))
explain format=tree select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
            -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select a, (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 1) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
a	(a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d))
explain format=tree select a, (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 1) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d));
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #8))  (cost=1127.50 rows=10000)
            -> Filter: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
                -> Table scan on t1  (cost=1127.50 rows=10000)
                -> Select #6 (subquery in condition; dependent)
                    -> Limit: 1 row(s)  (cost=227.60..227.60 rows=1)
                        -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                            -> Materialize  (cost=227.60..227.60 rows=1)
                                -> Limit: 1 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select a, (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d)) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
a	(a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)))
explain format=tree select a, (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d))) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d)) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)));
EXPLAIN
-> Nested loop semijoin  (cost=4921.70 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #8))  (cost=1127.50 rows=10000)
            -> Filter: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
                -> Table scan on t1  (cost=1127.50 rows=10000)
                -> Select #6 (subquery in condition; dependent)
                    -> Limit: 1 row(s)  (cost=227.60..227.60 rows=1)
                        -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                            -> Materialize  (cost=227.60..227.60 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 2) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 2) as d);
EXPLAIN
-> Nested loop semijoin  (cost=9255.20 rows=20000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.70..227.70 rows=2)
            -> Limit: 2 row(s)  (cost=227.50 rows=2)
                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.30 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.60..227.60 rows=1)
            -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 2) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 2) as d);
EXPLAIN
-> Nested loop semijoin  (cost=9255.20 rows=20000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.70..227.70 rows=2)
            -> Limit: 2 row(s)  (cost=227.50 rows=2)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=227.50 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 2, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a order by b limit 2, 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.30 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=227.60..227.60 rows=1)
            -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=227.50 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d);
EXPLAIN
-> Nested loop semijoin  (cost=9255.20 rows=20000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.73..827.73 rows=2)
            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d);
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d);
EXPLAIN
-> Nested loop semijoin  (cost=8255.30 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) and c > 1;
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) and c > 1;
EXPLAIN
-> Nested loop semijoin  (cost=5921.70 rows=20000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.73..827.73 rows=2)
            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) and c > 1;
a	b	c
explain format=tree select * from t1 where a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) and c > 1;
EXPLAIN
-> Nested loop semijoin  (cost=4921.80 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d);
a	b	c
explain format=tree select * from t1 where c > 1 having a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d);
EXPLAIN
-> Filter: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
            -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                -> Materialize  (cost=827.73..827.73 rows=2)
                    -> Limit: 2 row(s)  (cost=827.53 rows=2)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                            -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d));
a	b	c
explain format=tree select * from t1 where c > 1 having a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d));
EXPLAIN
-> Filter: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
            -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                -> Materialize  (cost=827.63..827.63 rows=1)
                    -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                        -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                            -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) from t1 where c > 1;
a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
0
0
0
explain format=tree select a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)) from t1 where c > 1;
a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))
0
0
0
explain format=tree select a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) from t1 where c > 1;
a	a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
1	0
2	0
3	0
explain format=tree select a, a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)) from t1 where c > 1;
a	a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))
1	0
2	0
3	0
explain format=tree select a, a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
EXPLAIN
-> Sort: <in_optimizer>(t1.a,<exists>(select #2))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d), a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) from t1 where c > 1;
b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)	a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
1	0
1	0
1	0
explain format=tree select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d), a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select b in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)), a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)) from t1 where c > 1;
b in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))	a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))
0	0
0	0
0	0
explain format=tree select b in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)), a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)) from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
(a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d))
explain format=tree select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
EXPLAIN
-> Nested loop semijoin  (cost=5921.70 rows=20000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.73..827.73 rows=2)
            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
(a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)))
explain format=tree select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
EXPLAIN
-> Nested loop semijoin  (cost=4921.80 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
(a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d))
explain format=tree select (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
EXPLAIN
-> Nested loop semijoin  (cost=5921.70 rows=20000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
            -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.73..827.73 rows=2)
            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
(a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)))
explain format=tree select (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
EXPLAIN
-> Nested loop semijoin  (cost=4921.80 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
            -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select a, (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 2) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
a	(a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d))
explain format=tree select a, (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) from t1 where a > 1 and (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 2) as d)) order by (a in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d));
EXPLAIN
-> Nested loop semijoin  (cost=5921.70 rows=20000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #8))  (cost=1127.50 rows=10000)
            -> Filter: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
                -> Table scan on t1  (cost=1127.50 rows=10000)
                -> Select #6 (subquery in condition; dependent)
                    -> Limit: 1 row(s)  (cost=227.70..227.70 rows=1)
                        -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                            -> Materialize  (cost=227.70..227.70 rows=2)
                                -> Limit: 2 row(s)  (cost=227.50 rows=2)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.73..827.73 rows=2)
            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select a, (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d)) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
a	(a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)))
explain format=tree select a, (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) from t1 where a > 1 and (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d))) having (a in ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d)) order by (a in ((select b from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)));
EXPLAIN
-> Nested loop semijoin  (cost=4921.80 rows=10000)
    -> Invalidate materialized tables (row from t1)  (cost=1127.50 rows=10000)
        -> Sort: <in_optimizer>(t1.a,<exists>(select #8))  (cost=1127.50 rows=10000)
            -> Filter: <in_optimizer>(t1.a,<exists>(select #6))  (cost=1127.50 rows=10000)
                -> Table scan on t1  (cost=1127.50 rows=10000)
                -> Select #6 (subquery in condition; dependent)
                    -> Limit: 1 row(s)  (cost=227.60..227.60 rows=1)
                        -> Index lookup on d using <auto_key0> (b=<cache>(t1.a))
                            -> Materialize  (cost=227.60..227.60 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
    -> Index lookup on d using <auto_key0> (b=t1.a)
        -> Materialize (invalidate on row from t1)  (cost=827.63..827.63 rows=1)
            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.a) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where a > any ( select * from (select b from t2 limit 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > any ( select * from (select b from t2 limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > any ( select * from (select b from t2 order by b limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where a > any ( select * from (select b from t2 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > any ( select * from (select b from t2 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  and c > 1;
a	b	c
3	4	5
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  and c > 1;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  and c > 1;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>((t1.a > (select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)

select a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
0
0
1
explain format=tree select a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
0
0
0
explain format=tree select a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
1	0
2	0
3	1
explain format=tree select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
1	0
2	0
3	0
explain format=tree select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select b in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 1) as d)	a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
1	0
0	0
0	1
explain format=tree select b in ( select * from (select b from t2 where a > 0 order by b limit 1) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.b = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.b)
                -> Materialize with deduplication  (cost=0.10..0.10 rows=1)
                    -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select b in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)	a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
0	0
1	0
0	0
explain format=tree select b in ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; run only once)
    -> Filter: ((t1.b = `<materialized_subquery>`.b))
        -> Limit: 1 row(s)
            -> Index lookup on <materialized_subquery> using <auto_distinct_key> (b=t1.b)
                -> Materialize with deduplication  (cost=1130.21..1130.21 rows=1)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=1130.11..1130.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                    -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) )
1
explain format=tree select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Filter: <nop>((t1.a > (select #4)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #4 (subquery in condition; run only once)
        -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Filter: <nop>((t1.a > (select #4)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #4 (subquery in condition; run only once)
        -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) )
1
explain format=tree select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1016.41 rows=10000)
    -> Filter: <nop>((t1.a > (select #4)))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1016.41 rows=10000)
    -> Filter: <nop>((t1.a > (select #4)))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) having (a > any ( select * from (select b from t2 limit 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
a	(a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) )
3	1
explain format=tree select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) having (a > any ( select * from (select b from t2 limit 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1016.41 rows=10000)
    -> Filter: (<nop>((t1.a > (select #4))) and <nop>((t1.a > (select #6))))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
        -> Select #6 (subquery in condition; run only once)
            -> Aggregate: min('2')  (cost=0.10..0.10 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) having (a > any ( select * from (select b from t2 limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
a	(a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) )
explain format=tree select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) having (a > any ( select * from (select b from t2 limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1016.41 rows=10000)
    -> Filter: (<nop>((t1.a > (select #4))) and <nop>((t1.a > (select #6))))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Aggregate: min(d.b)  (cost=1130.21..1130.21 rows=1)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > any ( select * from (select b from t2 limit 2) as d) ;
a	b	c
3	4	5
explain select * from t1 where a > any ( select * from (select b from t2 limit 2) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	66.67	Using where
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` limit 2) `d`)))
select * from t1 where a > any ( select * from (select b from t2 limit 2, 1) as d) ;
a	b	c
explain select * from t1 where a > any ( select * from (select b from t2 limit 2, 1) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	66.67	Using where
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	100.00	NULL
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` limit 2,1) `d`)))
select * from t1 where a > any ( select * from (select b from t2 order by b limit 2) as d) ;
a	b	c
3	4	5
explain select * from t1 where a > any ( select * from (select b from t2 order by b limit 2) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	66.67	Using where
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` order by `test123`.`t2`.`b` limit 2) `d`)))
select * from t1 where a > any ( select * from (select b from t2 order by b limit 2, 1) as d) ;
a	b	c
explain select * from t1 where a > any ( select * from (select b from t2 order by b limit 2, 1) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	66.67	Using where
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	100.00	Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` order by `test123`.`t2`.`b` limit 2,1) `d`)))
select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
a	b	c
3	4	5
explain select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	66.67	Using where
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d`)))
select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
a	b	c
explain select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	66.67	Using where
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d`)))
select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  and c > 1;
a	b	c
3	4	5
explain select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  and c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where (<nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d`))) and (`test123`.`t1`.`c` > 1))
select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  and c > 1;
a	b	c
explain select * from t1 where a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  and c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where (<nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d`))) and (`test123`.`t1`.`c` > 1))
select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
a	b	c
3	4	5
explain select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where (`test123`.`t1`.`c` > 1) having <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d`)))
select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
a	b	c
explain select * from t1 where c > 1 having a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,`test123`.`t1`.`b` AS `b`,`test123`.`t1`.`c` AS `c` from `test123`.`t1` where (`test123`.`t1`.`c` > 1) having <nop>((`test123`.`t1`.`a` > (/* select#2 */ select min(`d`.`b`) from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d`)))
select a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
0
0
1
explain select a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)` from `test123`.`t1` where (`test123`.`t1`.`c` > 1)
select a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
0
0
0
explain select a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)` from `test123`.`t1` where (`test123`.`t1`.`c` > 1)
select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
1	0
2	0
3	1
explain select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,<nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)` from `test123`.`t1` where (`test123`.`t1`.`c` > 1)
select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
1	0
2	0
3	0
explain select a, a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,<nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)` from `test123`.`t1` where (`test123`.`t1`.`c` > 1)
select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
a
1
2
3
explain select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a` from `test123`.`t1` where (`test123`.`t1`.`c` > 1) order by <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true))))
select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
a
1
2
3
explain select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a` from `test123`.`t1` where (`test123`.`t1`.`c` > 1) order by <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true))))
select b in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)	a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
1	0
1	0
0	1
explain select b in ( select * from (select b from t2 where a > 0 order by b limit 2) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
4	DEPENDENT SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <in_optimizer>(`test123`.`t1`.`b`,`test123`.`t1`.`b` in ( <materialize> (/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where true having true ), <primary_index_lookup>(`test123`.`t1`.`b` in <temporary table> on <auto_distinct_key> where ((`test123`.`t1`.`b` = `<materialized_subquery>`.`b`))))) AS `b in ( select * from (select b from t2 where a > 0 order by b limit 2) as d)`,<nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#4 */ select `d`.`b` from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d)` from `test123`.`t1` where (`test123`.`t1`.`c` > 1)
select b in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)	a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
0	0
0	0
1	0
explain select b in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) , a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t1`.`c` > 1)
4	DEPENDENT SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <in_optimizer>(`test123`.`t1`.`b`,`test123`.`t1`.`b` in ( <materialize> (/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where true having true ), <primary_index_lookup>(`test123`.`t1`.`b` in <temporary table> on <auto_distinct_key> where ((`test123`.`t1`.`b` = `<materialized_subquery>`.`b`))))) AS `b in ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)`,<nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#4 */ select `d`.`b` from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)` from `test123`.`t1` where (`test123`.`t1`.`c` > 1)
select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )
1
explain select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`a` > 1)
4	SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `(a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )` from `test123`.`t1` where ((`test123`.`t1`.`a` > 1) and <nop>((`test123`.`t1`.`a` > (/* select#4 */ select min(`d`.`b`) from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d`))))
select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )
explain select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`a` > 1)
4	SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `(a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )` from `test123`.`t1` where ((`test123`.`t1`.`a` > 1) and <nop>((`test123`.`t1`.`a` > (/* select#4 */ select min(`d`.`b`) from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d`))))
select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )
1
explain select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`a` > 1); Using filesort
6	DEPENDENT SUBQUERY	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
7	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
4	SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `(a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )` from `test123`.`t1` where ((`test123`.`t1`.`a` > 1) and <nop>((`test123`.`t1`.`a` > (/* select#4 */ select min(`d`.`b`) from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d`)))) order by <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#6 */ select `d`.`b` from (/* select#7 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true))))
select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
(a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )
explain select (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`a` > 1); Using filesort
6	DEPENDENT SUBQUERY	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
7	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
4	SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `(a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )` from `test123`.`t1` where ((`test123`.`t1`.`a` > 1) and <nop>((`test123`.`t1`.`a` > (/* select#4 */ select min(`d`.`b`) from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d`)))) order by <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#6 */ select `d`.`b` from (/* select#7 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true))))
select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) having (a > any ( select * from (select b from t2 limit 2) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
a	(a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )
3	1
explain select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) having (a > any ( select * from (select b from t2 limit 2) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`a` > 1); Using filesort
8	DEPENDENT SUBQUERY	<derived9>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
9	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
6	SUBQUERY	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
7	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	100.00	NULL
4	SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	NULL
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	2	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,<nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `(a > any ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )` from `test123`.`t1` where ((`test123`.`t1`.`a` > 1) and <nop>((`test123`.`t1`.`a` > (/* select#4 */ select min(`d`.`b`) from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d`)))) having <nop>((`test123`.`t1`.`a` > (/* select#6 */ select min(`d`.`b`) from (/* select#7 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` limit 2) `d`))) order by <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#8 */ select `d`.`b` from (/* select#9 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true))))
select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) having (a > any ( select * from (select b from t2 limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
a	(a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )
explain select a, (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) having (a > any ( select * from (select b from t2 limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	PRIMARY	t1	NULL	ALL	NULL	NULL	NULL	NULL	10000	22.22	Using where; Using pushed condition (`test123`.`t1`.`a` > 1); Using filesort
8	DEPENDENT SUBQUERY	<derived9>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
9	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
6	SUBQUERY	<derived7>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
7	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	100.00	NULL
4	SUBQUERY	<derived5>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	NULL
5	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
2	DEPENDENT SUBQUERY	<derived3>	NULL	ALL	NULL	NULL	NULL	NULL	3	100.00	Using where
3	DERIVED	t2	NULL	ALL	NULL	NULL	NULL	NULL	10000	33.33	Using where; Using pushed condition (`test123`.`t2`.`a` > 0); Using filesort
Warnings:
Note	1003	/* select#1 */ select `test123`.`t1`.`a` AS `a`,<nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#2 */ select `d`.`b` from (/* select#3 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true)))) AS `(a > any ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )` from `test123`.`t1` where ((`test123`.`t1`.`a` > 1) and <nop>((`test123`.`t1`.`a` > (/* select#4 */ select min(`d`.`b`) from (/* select#5 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d`)))) having <nop>((`test123`.`t1`.`a` > (/* select#6 */ select min(`d`.`b`) from (/* select#7 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` limit 2,1) `d`))) order by <nop>(<in_optimizer>(`test123`.`t1`.`a`,<exists>(/* select#8 */ select `d`.`b` from (/* select#9 */ select `test123`.`t2`.`b` AS `b` from `test123`.`t2` where (`test123`.`t2`.`a` > 0) order by `test123`.`t2`.`b` limit 2,1) `d` where <if>(outer_field_is_not_null, ((<cache>(`test123`.`t1`.`a`) > `d`.`b`) or (`d`.`b` is null)), true) having <if>(outer_field_is_not_null, <is_not_null_test>(`d`.`b`), true))))
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit: 1 row(s)  (cost=227.50 rows=1)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit: 1 row(s)  (cost=227.50 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  and c > 1;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  and c > 1;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
0
0
0
explain format=tree select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)
0
0
0
explain format=tree select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
1	0
2	0
3	0
explain format=tree select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)
1	0
2	0
3	0
explain format=tree select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
1	0
1	0
1	0
explain format=tree select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)
0	0
0	0
0	0
explain format=tree select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
a	(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) )
explain format=tree select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<nop>(<in_optimizer>(t1.a,<exists>(select #4))) and <nop>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=230.11..230.11 rows=1)
                                -> Limit: 1 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
a	(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) )
explain format=tree select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<nop>(<in_optimizer>(t1.a,<exists>(select #4))) and <nop>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=230.11..230.11 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.21..115.21 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.21..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.21..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=228.96..230.23 rows=2)
                            -> Limit: 2 row(s)  (cost=227.50 rows=2)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=152.68..152.68 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=152.68..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=152.68..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 2) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.21..115.21 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.21..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.21..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=228.96..230.23 rows=2)
                            -> Limit: 2 row(s)  (cost=227.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=152.68..152.68 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=152.68..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=152.68..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  and c > 1;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  and c > 1;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
0
0
0
explain format=tree select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)
0
0
0
explain format=tree select a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
1	0
2	0
3	0
explain format=tree select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)
1	0
2	0
3	0
explain format=tree select a, a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
1	0
1	0
1	0
explain format=tree select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.73..827.73 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.73..827.73 rows=2)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.73..827.73 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)	a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)
0	0
0	0
0	0
explain format=tree select b in ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) , a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=827.63..827.63 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=827.63..827.63 rows=1)
            -> Alternative plans for IN subquery: Index lookup unless b IS NULL [other sub-iterators not shown]
                -> Index lookup on d using <auto_key0> (b=<cache>(t1.b) or NULL)
                    -> Materialize  (cost=827.63..827.63 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                        -> Table scan on d  (cost=1.26..2.52 rows=2)
                            -> Materialize  (cost=828.99..830.25 rows=2)
                                -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) )
explain format=tree select (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <nop>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
a	(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) )
explain format=tree select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<nop>(<in_optimizer>(t1.a,<exists>(select #4))) and <nop>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                        -> Table scan on d  (cost=1.26..2.52 rows=2)
                            -> Materialize  (cost=828.99..830.25 rows=2)
                                -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=115.21..115.21 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.21..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=115.21..2.73 rows=2)
                        -> Table scan on d  (cost=1.26..2.52 rows=2)
                            -> Materialize  (cost=228.96..230.23 rows=2)
                                -> Limit: 2 row(s)  (cost=227.50 rows=2)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
a	(a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) )
explain format=tree select a, (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) having (a > any ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ) order by (a > any ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <nop>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<nop>(<in_optimizer>(t1.a,<exists>(select #4))) and <nop>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=152.68..152.68 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=152.68..2.84 rows=3)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=152.68..2.84 rows=3)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=230.11..230.11 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 limit 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > all ( select * from (select b from t2 limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 order by b limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > all ( select * from (select b from t2 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  and c > 1;
a	b	c
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  and c > 1;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  and c > 1;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
a	b	c
3	4	5
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
0
0
1
explain format=tree select a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
0
0
0
explain format=tree select a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
1	0
2	0
3	1
explain format=tree select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
1	0
2	0
3	0
explain format=tree select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select b > any(select * from(select b from t2 where a > 0 order by b limit 1) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where a > 0 order by b limit 1) as d)	a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)
0	0
1	0
1	1
explain format=tree select b > any(select * from(select b from t2 where a > 0 order by b limit 1) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select b > any(select * from(select b from t2 where a > 0 order by b limit 1, 1) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where a > 0 order by b limit 1, 1) as d)	a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)
0	0
0	0
1	0
explain format=tree select b > any(select * from(select b from t2 where a > 0 order by b limit 1, 1) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) )
1
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #4 (subquery in condition; run only once)
        -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #4 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) )
1
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1016.41 rows=10000)
    -> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1016.41 rows=10000)
    -> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) having (a > all ( select * from (select b from t2 limit 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
a	(a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) )
3	1
explain format=tree select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) ) having (a > all ( select * from (select b from t2 limit 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1016.41 rows=10000)
    -> Filter: (<not>((t1.a <= <max>(select #4))) and <not>((t1.a <= <max>(select #6))))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
        -> Select #6 (subquery in condition; run only once)
            -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=0.00..0.00 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>('2'), true)  (cost=0.00..0.00 rows=1)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= '2') or ('2' is null)), true)  (cost=0.00..0.00 rows=1)
                -> Rows fetched before execution  (cost=0.00..0.00 rows=1)

select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) having (a > all ( select * from (select b from t2 limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
a	(a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) )
explain format=tree select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) ) having (a > all ( select * from (select b from t2 limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1016.41 rows=10000)
    -> Filter: (<not>((t1.a <= <max>(select #4))) and <not>((t1.a <= <max>(select #6))))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.16..565.16 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.16..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.16..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 limit 2) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=1.26..2.52 rows=2)
            -> Materialize  (cost=1128.96..1130.23 rows=2)
                -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                    -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 order by b limit 2) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=1.26..2.52 rows=2)
            -> Materialize  (cost=1128.96..1130.23 rows=2)
                -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 order by b limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=1.26..2.52 rows=2)
            -> Materialize  (cost=1128.96..1130.23 rows=2)
                -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=794.20 rows=6667)
    -> Table scan on t1  (cost=794.20 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  and c > 1;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=1.26..2.52 rows=2)
            -> Materialize  (cost=1128.96..1130.23 rows=2)
                -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  and c > 1;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=1.26..2.52 rows=2)
            -> Materialize  (cost=1128.96..1130.23 rows=2)
                -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)

select a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
0
0
0
explain format=tree select a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
0
0
0
explain format=tree select a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
1	0
2	0
3	0
explain format=tree select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
1	0
2	0
3	0
explain format=tree select a, a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select b > any(select * from(select b from t2 where a > 0 order by b limit 2) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where a > 0 order by b limit 2) as d)	a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)
0	0
1	0
1	0
explain format=tree select b > any(select * from(select b from t2 where a > 0 order by b limit 2) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select b > any(select * from(select b from t2 where a > 0 order by b limit 2, 1) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where a > 0 order by b limit 2, 1) as d)	a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)
0	0
0	0
0	0
explain format=tree select b > any(select * from(select b from t2 where a > 0 order by b limit 2, 1) as d) , a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #4 (subquery in condition; run only once)
        -> Table scan on d  (cost=1.26..2.52 rows=2)
            -> Materialize  (cost=1128.96..1130.23 rows=2)
                -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=2222)
    -> Table scan on t1  (cost=1016.41 rows=10000)
    -> Select #4 (subquery in condition; run only once)
        -> Table scan on d  (cost=2.51..2.51 rows=1)
            -> Materialize  (cost=1130.11..1130.11 rows=1)
                -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1016.41 rows=10000)
    -> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Table scan on d  (cost=1.26..2.52 rows=2)
                -> Materialize  (cost=1128.96..1130.23 rows=2)
                    -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
(a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1016.41 rows=10000)
    -> Filter: <not>((t1.a <= <max>(select #4)))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) having (a > all ( select * from (select b from t2 limit 2) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
a	(a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) )
explain format=tree select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) ) having (a > all ( select * from (select b from t2 limit 2) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1016.41 rows=10000)
    -> Filter: (<not>((t1.a <= <max>(select #4))) and <not>((t1.a <= <max>(select #6))))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Table scan on d  (cost=1.26..2.52 rows=2)
                -> Materialize  (cost=1128.96..1130.23 rows=2)
                    -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                        -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Table scan on d  (cost=1.26..2.52 rows=2)
                -> Materialize  (cost=1128.96..1130.23 rows=2)
                    -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=565.21..565.21 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=565.21..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=565.21..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=1128.96..1130.23 rows=2)
                        -> Limit: 2 row(s)  (cost=1127.50 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) having (a > all ( select * from (select b from t2 limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
a	(a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) )
explain format=tree select a, (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) ) having (a > all ( select * from (select b from t2 limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1016.41 rows=10000)
    -> Filter: (<not>((t1.a <= <max>(select #4))) and <not>((t1.a <= <max>(select #6))))  (cost=1016.41 rows=10000)
        -> Table scan on t1  (cost=1016.41 rows=10000)
        -> Select #4 (subquery in condition; run only once)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                        -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                            -> Table scan on t2  (cost=1127.50 rows=10000)
        -> Select #6 (subquery in condition; run only once)
            -> Table scan on d  (cost=2.51..2.51 rows=1)
                -> Materialize  (cost=1130.11..1130.11 rows=1)
                    -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                        -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=752.68..752.68 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=752.68..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=752.68..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=1130.11..1130.11 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=1127.50 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                                -> Table scan on t2  (cost=1127.50 rows=10000)

select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit: 1 row(s)  (cost=227.50 rows=1)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit: 1 row(s)  (cost=227.50 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 1, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  and c > 1;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  and c > 1;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  and c > 1;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
0
0
0
explain format=tree select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)
1
1
1
explain format=tree select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
1	0
2	0
3	0
explain format=tree select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)
1	1
2	1
3	1
explain format=tree select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)
0	0
0	0
0	0
explain format=tree select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)
0	1
0	1
0	1
explain format=tree select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) )
1
1
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) )
1
1
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
a	(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) )
explain format=tree select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<not>(<in_optimizer>(t1.a,<exists>(select #4))) and <not>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit: 1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=230.11..230.11 rows=1)
                                -> Limit: 1 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit: 1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 1 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
a	(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) )
2	1
3	1
explain format=tree select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 1, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 1, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<not>(<in_optimizer>(t1.a,<exists>(select #4))) and <not>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=115.16..115.16 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.16..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.16..2.73 rows=2)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=230.11..230.11 rows=1)
                                -> Limit/Offset: 1/1 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.18..415.18 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.18..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.18..2.73 rows=2)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/1 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.21..115.21 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.21..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.21..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=228.96..230.23 rows=2)
                            -> Limit: 2 row(s)  (cost=227.50 rows=2)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=152.68..152.68 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=152.68..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=152.68..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                                -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                    -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 2) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=115.21..115.21 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.21..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.21..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=228.96..230.23 rows=2)
                            -> Limit: 2 row(s)  (cost=227.50 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 2, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=152.68..152.68 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=152.68..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=152.68..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=230.11..230.11 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=227.50 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=10000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  and c > 1;
a	b	c
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  and c > 1;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  and c > 1;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  and c > 1;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
a	b	c
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
a	b	c
1	2	3
2	3	4
3	4	5
explain format=tree select * from t1 where c > 1 having a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ;
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #2 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
0
0
0
explain format=tree select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)
1
1
1
explain format=tree select a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
1	0
2	0
3	0
explain format=tree select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
a	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)
1	1
2	1
3	1
explain format=tree select a, a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
a
1
2
3
explain format=tree select a from t1 where c > 1 order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #2)))  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)
0	0
0	0
0	0
explain format=tree select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)	a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)
0	1
0	1
0	1
explain format=tree select b > any(select * from(select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) , a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d)  from t1 where c > 1;
EXPLAIN
-> Table scan on t1  (cost=1127.50 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.b) > d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #4 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                    -> Table scan on d  (cost=1.26..2.52 rows=2)
                        -> Materialize  (cost=828.99..830.25 rows=2)
                            -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) )
1
1
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=3333)
    -> Table scan on t1  (cost=1127.50 rows=10000)
    -> Select #4 (subquery in condition; dependent)
        -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
            -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                    -> Table scan on d  (cost=2.51..2.51 rows=1)
                        -> Materialize  (cost=830.14..830.14 rows=1)
                            -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                    -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                        -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) )
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                        -> Table scan on d  (cost=1.26..2.52 rows=2)
                            -> Materialize  (cost=828.99..830.25 rows=2)
                                -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) )
1
1
explain format=tree select (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #6)))  (cost=1127.50 rows=10000)
    -> Filter: <not>(<in_optimizer>(t1.a,<exists>(select #4)))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #6 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
a	(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) )
explain format=tree select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 2) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<not>(<in_optimizer>(t1.a,<exists>(select #4))) and <not>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                        -> Table scan on d  (cost=1.26..2.52 rows=2)
                            -> Materialize  (cost=828.99..830.25 rows=2)
                                -> Limit: 2 row(s)  (cost=827.53 rows=2)
                                    -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=115.21..115.21 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=115.21..2.73 rows=2)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=115.21..2.73 rows=2)
                        -> Table scan on d  (cost=1.26..2.52 rows=2)
                            -> Materialize  (cost=228.96..230.23 rows=2)
                                -> Limit: 2 row(s)  (cost=227.50 rows=2)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=415.23..415.23 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=415.23..2.73 rows=2)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=415.23..2.73 rows=2)
                -> Table scan on d  (cost=1.26..2.52 rows=2)
                    -> Materialize  (cost=828.99..830.25 rows=2)
                        -> Limit: 2 row(s)  (cost=827.53 rows=2)
                            -> Sort: t2.b, limit input to 2 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
a	(a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) )
2	1
3	1
explain format=tree select a, (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) from t1 where a > 1 and (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) ) having (a > all ( select * from (select b from t2 where t2.a=t1.a limit 2, 1) as d) ) order by (a > all ( select * from (select b from t2 where t2.a=t1.a and a > 0 order by b limit 2, 1) as d) );
EXPLAIN
-> Sort: <not>(<in_optimizer>(t1.a,<exists>(select #8)))  (cost=1127.50 rows=10000)
    -> Filter: (<not>(<in_optimizer>(t1.a,<exists>(select #4))) and <not>(<in_optimizer>(t1.a,<exists>(select #6))))  (cost=1127.50 rows=10000)
        -> Table scan on t1  (cost=1127.50 rows=10000)
        -> Select #4 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=830.14..830.14 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                                    -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                        -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                            -> Table scan on t2  (cost=827.53 rows=10000)
        -> Select #6 (subquery in condition; dependent)
            -> Limit: 1 row(s)  (cost=152.68..152.68 rows=1)
                -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=152.68..2.84 rows=3)
                    -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=152.68..2.84 rows=3)
                        -> Table scan on d  (cost=2.51..2.51 rows=1)
                            -> Materialize  (cost=230.11..230.11 rows=1)
                                -> Limit/Offset: 1/2 row(s)  (cost=227.50 rows=1)
                                    -> Filter: (t2.a = t1.a)  (cost=227.50 rows=1000)
                                        -> Table scan on t2  (cost=227.50 rows=10000)
-> Select #8 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)
-> Select #2 (subquery in projection; dependent)
    -> Limit: 1 row(s)  (cost=552.70..552.70 rows=1)
        -> Filter: <if>(outer_field_is_not_null, <is_not_null_test>(d.b), true)  (cost=552.70..2.84 rows=3)
            -> Filter: <if>(outer_field_is_not_null, ((<cache>(t1.a) <= d.b) or (d.b is null)), true)  (cost=552.70..2.84 rows=3)
                -> Table scan on d  (cost=2.51..2.51 rows=1)
                    -> Materialize  (cost=830.14..830.14 rows=1)
                        -> Limit/Offset: 1/2 row(s)  (cost=827.53 rows=1)
                            -> Sort: t2.b, limit input to 3 row(s) per chunk  (cost=827.53 rows=10000)
                                -> Filter: (t2.a = t1.a)  (cost=827.53 rows=10000)
                                    -> Table scan on t2  (cost=827.53 rows=10000)

Warnings:
Note	1276	Field or reference 'test123.t1.a' of SELECT #3 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #5 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #7 was resolved in SELECT #1
Note	1276	Field or reference 'test123.t1.a' of SELECT #9 was resolved in SELECT #1
drop table t1, t2;
drop database test123;
