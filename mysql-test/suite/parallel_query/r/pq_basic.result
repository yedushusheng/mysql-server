### enable parallel query forcibly with maximum parallel degree = 4 and cost/records threshold = 0 ###
CREATE TABLE t1(a int, b int, c int);
INSERT INTO t1 VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
###
### some basic queries
###
EXPLAIN format=tree SELECT * FROM t1;
EXPLAIN
-> Gather (slice: 1, workers: 4)  (cost=N.NNN rows=NNN)
    -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT * FROM t1;
a	b	c
1	1	1
1	1	1
2	2	2
2	2	2
3	3	3
3	3	3
4	4	4
4	4	4
5	5	5
5	5	5
EXPLAIN format=tree SELECT * FROM t1 where a > 1;
EXPLAIN
-> Gather (slice: 1, workers: 4)  (cost=N.NNN rows=NNN)
    -> Filter: (t1.a > 1)  (cost=N.NNN rows=NNN)
        -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT * FROM t1 where a > 1;
a	b	c
2	2	2
2	2	2
3	3	3
3	3	3
4	4	4
4	4	4
5	5	5
5	5	5
EXPLAIN format=tree SELECT sum(a) FROM t1;
EXPLAIN
-> Aggregate: sum(a)  (cost=N.NNN rows=NNN)
    -> Gather (slice: 1, workers: 4)
        -> Aggregate: sum(t1.a)  (cost=N.NNN rows=NNN)
            -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT sum(a) FROM t1;
sum(a)
30
EXPLAIN format=tree SELECT a FROM t1 GROUP BY a;
EXPLAIN
-> Table scan on <temporary>  (cost=0.26..2.62 rows=10)
    -> Temporary table with deduplication  (cost=2.51..4.88 rows=10)
        -> Gather (slice: 1, workers: 4)
            -> Table scan on <temporary>  (cost=0.26..2.62 rows=10)
                -> Temporary table with deduplication  (cost=2.51..4.88 rows=10)
                    -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT a FROM t1 GROUP BY a;
a
1
2
3
4
5
EXPLAIN format=tree SELECT sum(b) FROM t1 GROUP BY a;
EXPLAIN
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Gather (slice: 1, workers: 4)
            -> Table scan on <temporary>
                -> Aggregate using temporary table
                    -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT sum(b) FROM t1 GROUP BY a;
sum(b)
10
2
4
6
8
EXPLAIN format=tree SELECT a, sum(b) FROM t1 GROUP BY a;
EXPLAIN
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Gather (slice: 1, workers: 4)
            -> Table scan on <temporary>
                -> Aggregate using temporary table
                    -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT a, sum(b) FROM t1 GROUP BY a;
a	sum(b)
1	2
2	4
3	6
4	8
5	10
EXPLAIN format=tree SELECT a, sum(b) FROM t1 GROUP BY a order by 2;
EXPLAIN
-> Sort: `sum(b)`
    -> Table scan on <temporary>
        -> Aggregate using temporary table
            -> Gather (slice: 1, workers: 4)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT a, sum(b) FROM t1 GROUP BY a order by 2;
a	sum(b)
1	2
2	4
3	6
4	8
5	10
EXPLAIN format=tree SELECT a, sum(b) + 1 FROM t1 GROUP BY a order by 2;
EXPLAIN
-> Sort: (sum(b) + 1)
    -> Table scan on <temporary>
        -> Aggregate using temporary table
            -> Gather (slice: 1, workers: 4)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT a, sum(b) + 1 FROM t1 GROUP BY a order by 2;
a	sum(b) + 1
1	3
2	5
3	7
4	9
5	11
###
### access path coverage
###
### aggregate access path ###
EXPLAIN format=tree SELECT SQL_BIG_RESULT a FROM t1 GROUP BY a;
EXPLAIN
-> Group (no aggregates)  (cost=N.NNN rows=NNN)
    -> Gather (slice: 1, workers: 4) with merge sort: t1.a
        -> Group (no aggregates)  (cost=N.NNN rows=NNN)
            -> Sort: t1.a  (cost=N.NNN rows=NNN)
                -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT SQL_BIG_RESULT a FROM t1 GROUP BY a;
a
1
2
3
4
5
### stream access path ###
EXPLAIN format=tree SELECT DISTINCT SQL_BIG_RESULT a FROM t1 GROUP BY a,b ORDER BY a DESC;
EXPLAIN
-> Sort: t1.a DESC, t1.b
    -> Sort with duplicate removal: t1.a DESC
        -> Stream results  (cost=N.NNN rows=NNN)
            -> Group (no aggregates)  (cost=N.NNN rows=NNN)
                -> Gather (slice: 1, workers: 4) with merge sort: t1.a DESC, t1.b
                    -> Group (no aggregates)  (cost=N.NNN rows=NNN)
                        -> Sort: t1.a DESC, t1.b  (cost=N.NNN rows=NNN)
                            -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT DISTINCT SQL_BIG_RESULT a FROM t1 GROUP BY a,b ORDER BY a DESC;
a
1
2
3
4
5
### 2 temporary tables ###
EXPLAIN format=tree SELECT DISTINCT (COUNT(b) + 1) AS c FROM t1 WHERE b > 1 GROUP BY a;
EXPLAIN
-> Table scan on <temporary>  (cost=2.50..2.50 rows=0)
    -> Temporary table with deduplication  (cost=2.50..2.50 rows=0)
        -> Table scan on <temporary>
            -> Aggregate using temporary table
                -> Gather (slice: 1, workers: 4)
                    -> Table scan on <temporary>
                        -> Aggregate using temporary table
                            -> Filter: (t1.b > 1)  (cost=N.NNN rows=NNN)
                                -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT DISTINCT (COUNT(b) + 1) AS c FROM t1 WHERE b > 1 GROUP BY a;
c
3
### offset limit ###
EXPLAIN format=tree SELECT * FROM t1 LIMIT 2 OFFSET 1;
EXPLAIN
-> Limit/Offset: 2/1 row(s)  (cost=N.NNN rows=NNN)
    -> Gather (slice: 1, workers: 4)
        -> Limit: 3 row(s)  (cost=N.NNN rows=NNN)
            -> Table scan on t1  (cost=N.NNN rows=NNN)

include/assert.inc [result value must be in table]
EXPLAIN format=tree SELECT * FROM t1 ORDER BY a LIMIT 2 OFFSET 1;
EXPLAIN
-> Limit/Offset: 2/1 row(s)  (cost=N.NNN rows=NNN)
    -> Gather (slice: 1, workers: 4) with merge sort: t1.a
        -> Limit: 3 row(s)  (cost=N.NNN rows=NNN)
            -> Sort: t1.a, limit input to 3 row(s) per chunk  (cost=N.NNN rows=NNN)
                -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT * FROM t1 ORDER BY a LIMIT 2 OFFSET 1;
a	b	c
1	1	1
2	2	2
### having ###
EXPLAIN format=tree SELECT sum(b) FROM t1 GROUP BY a HAVING sum(b) > 5;
EXPLAIN
-> Filter: (sum(b) > 5)
    -> Table scan on <temporary>
        -> Aggregate using temporary table
            -> Gather (slice: 1, workers: 4)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on t1  (cost=N.NNN rows=NNN)

SELECT sum(b) FROM t1 GROUP BY a HAVING sum(b) > 5;
sum(b)
10
6
8
EXPLAIN format=tree SELECT sum(b) as sumb FROM t1 GROUP BY a HAVING sum(b) > 5 LIMIT 1 OFFSET 2;
EXPLAIN
-> Limit/Offset: 1/2 row(s)
    -> Filter: (sum(b) > 5)
        -> Table scan on <temporary>
            -> Aggregate using temporary table
                -> Gather (slice: 1, workers: 4)
                    -> Table scan on <temporary>
                        -> Aggregate using temporary table
                            -> Table scan on t1  (cost=N.NNN rows=NNN)

include/assert.inc [value must be in query result]
DROP TABLE t1;
###
### bottom access path type coverage
###
### index scan ###
CREATE TABLE t1(a int, b int, c int, index(b));
INSERT INTO t1 VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
EXPLAIN format=tree SELECT b FROM t1;
EXPLAIN
-> Gather (slice: 1, workers: 4)  (cost=N.NNN rows=NNN)
    -> Index scan on t1 using b  (cost=N.NNN rows=NNN)

SELECT b FROM t1;
b
1
1
2
2
3
3
4
4
5
5
EXPLAIN format=tree SELECT b FROM t1 LIMIT 4;
EXPLAIN
-> Limit: 4 row(s)  (cost=N.NNN rows=NNN)
    -> Gather (slice: 1, workers: 4)
        -> Limit: 4 row(s)  (cost=N.NNN rows=NNN)
            -> Index scan on t1 using b  (cost=N.NNN rows=NNN)

include/assert.inc [result value must be in table]
EXPLAIN format=tree SELECT b FROM t1 ORDER BY b LIMIT 4;
EXPLAIN
-> Limit: 4 row(s)  (cost=N.NNN rows=NNN)
    -> Gather (slice: 1, workers: 4) with merge sort: t1.b
        -> Limit: 4 row(s)  (cost=N.NNN rows=NNN)
            -> Index scan on t1 using b  (cost=N.NNN rows=NNN)

SELECT b FROM t1 ORDER BY b LIMIT 4;
b
1
1
2
2
EXPLAIN format=tree SELECT b FROM t1 GROUP BY b LIMIT 4;
EXPLAIN
-> Limit: 4 row(s)  (cost=N.NNN rows=NNN)
    -> Gather (slice: 1, workers: 4) with merge sort: t1.b
        -> Limit: 4 row(s)  (cost=N.NNN rows=NNN)
            -> Index range scan on t1 using index_for_group_by(b)  (cost=N.NNN rows=NNN)

SELECT b FROM t1 GROUP BY b LIMIT 4;
b
1
2
3
4
EXPLAIN format=tree SELECT count(a), b FROM t1 GROUP BY b ORDER BY 2,1 LIMIT 4;
EXPLAIN
-> Limit: 4 row(s)
    -> Sort: t1.b, `count(a)`, limit input to 4 row(s) per chunk
        -> Stream results  (cost=N.NNN rows=NNN)
            -> Group aggregate: count(a)  (cost=N.NNN rows=NNN)
                -> Gather (slice: 1, workers: 4) with merge sort: t1.b
                    -> Group aggregate: count(t1.a)  (cost=N.NNN rows=NNN)
                        -> Index scan on t1 using b  (cost=N.NNN rows=NNN)

SELECT count(a), b FROM t1 GROUP BY b ORDER BY 2,1 LIMIT 4;
count(a)	b
2	1
2	2
2	3
2	4
### range index scan ###
EXPLAIN format=tree SELECT a FROM t1 WHERE b BETWEEN 2 AND 5;
EXPLAIN
-> Gather (slice: 1, workers: 4)  (cost=N.NNN rows=NNN)
    -> Index range scan on t1 using b, with index condition: (t1.b between 2 and 5)  (cost=N.NNN rows=NNN)

SELECT a FROM t1 WHERE b BETWEEN 2 AND 5;
a
2
2
3
3
4
4
5
5
### ref scan ###
EXPLAIN format=tree SELECT a FROM t1 WHERE b = 2;
EXPLAIN
-> Gather (slice: 1, workers: 4)  (cost=N.NNN rows=NNN)
    -> Index lookup on t1 using b (b=2)  (cost=N.NNN rows=NNN)

SELECT a FROM t1 WHERE b = 2;
a
2
2
### ref or null scan ###
EXPLAIN format=tree SELECT a FROM t1 WHERE b = 2 or b is NULL;
EXPLAIN
-> Gather (slice: 1, workers: 4)  (cost=N.NNN rows=NNN)
    -> Index lookup on t1 using b (b=2 or NULL), with index condition: ((t1.b = 2) or (t1.b is null))  (cost=N.NNN rows=NNN)

SELECT a FROM t1 WHERE b = 2 or b is NULL;
a
2
2
DROP TABLE t1;
### group min max scan ###
CREATE TABLE t1 (
a1 CHAR(64), a2 CHAR(64), b CHAR(16), c CHAR(16) not null, d CHAR(16), dummy CHAR(248) default ' '
) charset latin1;
INSERT INTO t1 (a1, a2, b, c, d) VALUES
('a','a','a','a111','xy1'),('a','a','a','b111','xy2'),('a','a','a','c111','xy3'),('a','a','a','d111','xy4'),
('a','a','b','e112','xy1'),('a','a','b','f112','xy2'),('a','a','b','g112','xy3'),('a','a','b','h112','xy4');
CREATE INDEX idx_t1_0 ON t1 (a1);
CREATE INDEX idx_t1_1 ON t1 (a1,a2,b,c);
CREATE INDEX idx_t1_2 ON t1 (a1,a2,b);
EXPLAIN format=tree SELECT a1, MIN(a2),MAX(a2) FROM t1 GROUP BY a1;
EXPLAIN
-> Gather (slice: 1, workers: 4) with merge sort: t1.a1  (cost=N.NNN rows=NNN)
    -> Index range scan on t1 using index_for_group_by(idx_t1_1)  (cost=N.NNN rows=NNN)

SELECT a1, MIN(a2),MAX(a2) FROM t1 GROUP BY a1;
a1	MIN(a2)	MAX(a2)
a	a	a
DROP TABLE t1;
### index skip scan ###
CREATE TABLE t1(a INT, b INT, c INT, d INT, PRIMARY KEY(a, b, c, d), KEY(b, d));
INSERT INTO t1 VALUES(1,1,1,1),(2,2,2,2),(3,3,3,3),(4,4,4,4),(5,5,5,5),(1,1,1,6),(2,2,2,6),(3,3,3,6),(4,4,4,6),(5,5,5,6);
EXPLAIN format=tree SELECT /*+ SKIP_SCAN(t1) */ a, b, c, d FROM t1 WHERE a IN (1, 2, 3, 4, 5) AND b IN (1, 2, 3) AND d >= 4;
EXPLAIN
-> Gather (slice: 1, workers: 4)  (cost=N.NNN rows=NNN)
    -> Filter: ((t1.a in (1,2,3,4,5)) and (t1.b in (1,2,3)) and (t1.d >= 4))  (cost=N.NNN rows=NNN)
        -> Index range scan on t1 using index_for_skip_scan(PRIMARY)  (cost=N.NNN rows=NNN)

SELECT /*+ SKIP_SCAN(t1) */ a, b, c, d FROM t1 WHERE a IN (1, 2, 3, 4, 5) AND b IN (1, 2, 3) AND d >= 4;
a	b	c	d
1	1	1	6
2	2	2	6
3	3	3	6
DROP TABLE t1;
