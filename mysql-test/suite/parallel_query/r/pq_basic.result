enable parallel query with max_parallel_degree = 1
CREATE TABLE t1(a int, b int, c int);
INSERT INTO t1 VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
###
### some basic queries
###
EXPLAIN format=tree SELECT * FROM t1;;
EXPLAIN
-> Gather (slice: 1, workers: 1)  (cost=1127.50 rows=10000)
    -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT * FROM t1;;
a	b	c
1	1	1
1	1	1
2	2	2
2	2	2
3	3	3
3	3	3
4	4	4
4	4	4
5	5	5
5	5	5
EXPLAIN format=tree SELECT * FROM t1 where a > 1;;
EXPLAIN
-> Gather (slice: 1, workers: 1)  (cost=1127.50 rows=3333)
    -> Filter: (t1.a > 1)  (cost=1127.50 rows=3333)
        -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT * FROM t1 where a > 1;;
a	b	c
2	2	2
2	2	2
3	3	3
3	3	3
4	4	4
4	4	4
5	5	5
5	5	5
EXPLAIN format=tree SELECT sum(a) FROM t1;;
EXPLAIN
-> Aggregate: sum(a)  (cost=2127.50 rows=10000)
    -> Gather (slice: 1, workers: 1)
        -> Aggregate: sum(t1.a)  (cost=2127.50 rows=10000)
            -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT sum(a) FROM t1;;
sum(a)
30
EXPLAIN format=tree SELECT a FROM t1 GROUP BY a;;
EXPLAIN
-> Table scan on <temporary>  (cost=0.01..127.50 rows=10000)
    -> Temporary table with deduplication  (cost=2127.51..2255.00 rows=10000)
        -> Gather (slice: 1, workers: 1)
            -> Table scan on <temporary>  (cost=0.01..127.50 rows=10000)
                -> Temporary table with deduplication  (cost=2127.51..2255.00 rows=10000)
                    -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT a FROM t1 GROUP BY a;;
a
1
2
3
4
5
EXPLAIN format=tree SELECT sum(b) FROM t1 GROUP BY a;;
EXPLAIN
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Gather (slice: 1, workers: 1)
            -> Table scan on <temporary>
                -> Aggregate using temporary table
                    -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT sum(b) FROM t1 GROUP BY a;;
sum(b)
10
2
4
6
8
EXPLAIN format=tree SELECT a, sum(b) FROM t1 GROUP BY a;;
EXPLAIN
-> Table scan on <temporary>
    -> Aggregate using temporary table
        -> Gather (slice: 1, workers: 1)
            -> Table scan on <temporary>
                -> Aggregate using temporary table
                    -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT a, sum(b) FROM t1 GROUP BY a;;
a	sum(b)
1	2
2	4
3	6
4	8
5	10
EXPLAIN format=tree SELECT a, sum(b) FROM t1 GROUP BY a order by 2;;
EXPLAIN
-> Sort: `sum(b)`
    -> Table scan on <temporary>
        -> Aggregate using temporary table
            -> Gather (slice: 1, workers: 1)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT a, sum(b) FROM t1 GROUP BY a order by 2;;
a	sum(b)
1	2
2	4
3	6
4	8
5	10
EXPLAIN format=tree SELECT a, sum(b) + 1 FROM t1 GROUP BY a order by 2;;
EXPLAIN
-> Sort: (`sum(b)` + 1)
    -> Table scan on <temporary>
        -> Aggregate using temporary table
            -> Gather (slice: 1, workers: 1)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT a, sum(b) + 1 FROM t1 GROUP BY a order by 2;;
a	sum(b) + 1
1	3
2	5
3	7
4	9
5	11
###
### access path coverage
###
### aggregate access path ###
EXPLAIN format=tree SELECT SQL_BIG_RESULT a FROM t1 GROUP BY a;;
EXPLAIN
-> Group (no aggregates)  (cost=2127.50 rows=10000)
    -> Gather (slice: 1, workers: 1) with merge sort: t1.a
        -> Group (no aggregates)  (cost=2127.50 rows=10000)
            -> Sort: t1.a  (cost=1127.50 rows=10000)
                -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT SQL_BIG_RESULT a FROM t1 GROUP BY a;;
a
1
2
3
4
5
### stream access path ###
EXPLAIN format=tree SELECT DISTINCT SQL_BIG_RESULT a FROM t1 GROUP BY a,b ORDER BY a DESC;;
EXPLAIN
-> Sort: t1.a DESC, t1.b
    -> Sort with duplicate removal: t1.a DESC
        -> Stream results  (cost=2127.50 rows=10000)
            -> Group (no aggregates)  (cost=2127.50 rows=10000)
                -> Gather (slice: 1, workers: 1) with merge sort: t1.a DESC, t1.b
                    -> Group (no aggregates)  (cost=2127.50 rows=10000)
                        -> Sort: t1.a DESC, t1.b  (cost=1127.50 rows=10000)
                            -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT DISTINCT SQL_BIG_RESULT a FROM t1 GROUP BY a,b ORDER BY a DESC;;
a
1
2
3
4
5
### 2 temporary tables ###
EXPLAIN format=tree SELECT DISTINCT (COUNT(b) + 1) AS c FROM t1 WHERE b > 1 GROUP BY a;;
EXPLAIN
-> Table scan on <temporary>  (cost=2.50..2.50 rows=0)
    -> Temporary table with deduplication  (cost=2.50..2.50 rows=0)
        -> Table scan on <temporary>
            -> Aggregate using temporary table
                -> Gather (slice: 1, workers: 1)
                    -> Table scan on <temporary>
                        -> Aggregate using temporary table
                            -> Filter: (t1.b > 1)  (cost=1127.50 rows=3333)
                                -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT DISTINCT (COUNT(b) + 1) AS c FROM t1 WHERE b > 1 GROUP BY a;;
c
3
### offset limit ###
EXPLAIN format=tree SELECT * FROM t1 LIMIT 2 OFFSET 1;;
EXPLAIN
-> Limit/Offset: 2/1 row(s)  (cost=1127.50 rows=2)
    -> Gather (slice: 1, workers: 1)
        -> Limit: 3 row(s)  (cost=1127.50 rows=2)
            -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT * FROM t1 LIMIT 2 OFFSET 1;;
a	b	c
2	2	2
3	3	3
EXPLAIN format=tree SELECT * FROM t1 ORDER BY a LIMIT 2 OFFSET 1;;
EXPLAIN
-> Limit/Offset: 2/1 row(s)  (cost=1127.50 rows=2)
    -> Gather (slice: 1, workers: 1) with merge sort: t1.a
        -> Limit: 3 row(s)  (cost=1127.50 rows=2)
            -> Sort: t1.a, limit input to 3 row(s) per chunk  (cost=1127.50 rows=10000)
                -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT * FROM t1 ORDER BY a LIMIT 2 OFFSET 1;;
a	b	c
1	1	1
2	2	2
### having ###
EXPLAIN format=tree SELECT sum(b) FROM t1 GROUP BY a HAVING sum(b) > 5;;
EXPLAIN
-> Filter: (sum(b) > 5)
    -> Table scan on <temporary>
        -> Aggregate using temporary table
            -> Gather (slice: 1, workers: 1)
                -> Table scan on <temporary>
                    -> Aggregate using temporary table
                        -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT sum(b) FROM t1 GROUP BY a HAVING sum(b) > 5;;
sum(b)
10
6
8
EXPLAIN format=tree SELECT sum(b) FROM t1 GROUP BY a HAVING sum(b) > 5 LIMIT 1 OFFSET 2;;
EXPLAIN
-> Limit/Offset: 1/2 row(s)
    -> Filter: (sum(b) > 5)
        -> Table scan on <temporary>
            -> Aggregate using temporary table
                -> Gather (slice: 1, workers: 1)
                    -> Table scan on <temporary>
                        -> Aggregate using temporary table
                            -> Table scan on t1  (cost=1127.50 rows=10000)

SELECT sum(b) FROM t1 GROUP BY a HAVING sum(b) > 5 LIMIT 1 OFFSET 2;;
sum(b)
10
DROP TABLE t1;
###
### bottom access path type coverage
###
### index scan ###
CREATE TABLE t1(a int, b int, c int, index(b));
INSERT INTO t1 VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
EXPLAIN format=tree SELECT b FROM t1;;
EXPLAIN
-> Gather (slice: 1, workers: 1)  (cost=1127.50 rows=10000)
    -> Index scan on t1 using b  (cost=1127.50 rows=10000)

SELECT b FROM t1;;
b
1
1
2
2
3
3
4
4
5
5
EXPLAIN format=tree SELECT b FROM t1 LIMIT 4;;
EXPLAIN
-> Limit: 4 row(s)  (cost=1127.50 rows=4)
    -> Gather (slice: 1, workers: 1)
        -> Limit: 4 row(s)  (cost=1127.50 rows=4)
            -> Index scan on t1 using b  (cost=1127.50 rows=10000)

SELECT b FROM t1 LIMIT 4;;
b
1
1
2
2
EXPLAIN format=tree SELECT b FROM t1 ORDER BY b LIMIT 4;;
EXPLAIN
-> Limit: 4 row(s)  (cost=0.05 rows=4)
    -> Gather (slice: 1, workers: 1) with merge sort: t1.b
        -> Limit: 4 row(s)  (cost=0.05 rows=4)
            -> Index scan on t1 using b  (cost=0.05 rows=4)

SELECT b FROM t1 ORDER BY b LIMIT 4;;
b
1
1
2
2
EXPLAIN format=tree SELECT b FROM t1 GROUP BY b LIMIT 4;;
EXPLAIN
-> Limit: 4 row(s)  (cost=0.45 rows=4)
    -> Group (no aggregates)  (cost=0.45 rows=4)
        -> Gather (slice: 1, workers: 1) with merge sort: t1.b
            -> Group (no aggregates)  (cost=0.45 rows=4)
                -> Index scan on t1 using b  (cost=0.05 rows=4)

SELECT b FROM t1 GROUP BY b LIMIT 4;;
b
1
2
3
4
EXPLAIN format=tree SELECT count(a), b FROM t1 GROUP BY b ORDER BY 2,1 LIMIT 4;;
EXPLAIN
-> Limit: 4 row(s)
    -> Sort: t1.b, `count(a)`, limit input to 4 row(s) per chunk
        -> Stream results  (cost=2127.50 rows=10000)
            -> Group aggregate: count(a)  (cost=2127.50 rows=10000)
                -> Gather (slice: 1, workers: 1) with merge sort: t1.b
                    -> Group aggregate: count(t1.a)  (cost=2127.50 rows=10000)
                        -> Index scan on t1 using b  (cost=1127.50 rows=10000)

SELECT count(a), b FROM t1 GROUP BY b ORDER BY 2,1 LIMIT 4;;
count(a)	b
2	1
2	2
2	3
2	4
DROP TABLE t1;
