# support spceify shard_key in comment for spider
--disable_warnings
--source ../include/init_spider.inc
--source ../include/pq_default.inc

let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, a INT, b INT, c INT);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (a, b, c) VALUES(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5);
--let $query = SELECT a FROM t1 HAVING a = 1
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc

--disable_testcase BUG#000
# Item_ref clone should set Item::context because create_tmp_table use it see sort_copy_func().
let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, a INT);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (a) VALUES(1),(2),(3);
--let $query = SELECT IF( a = 1, a, a ) AS `b` FROM t1 ORDER BY field( `b` + 1, 1 )
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc
--enable_testcase

# Inner-most query block's condition refer to temp table field of outer block
# with condition()->used_tables() = 1 (should return a value with bit
# OUTER_REF_TABLE_BIT set.)
let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, f1 INT);
let shardkey=id;
--source include/create_spider_table.inc
--let $query = SELECT (SELECT COUNT(*) + (SELECT COUNT(*) FROM t1 WHERE f1 = c.f2) FROM t1) FROM (SELECT 555 AS f2) AS c
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc

# max() was optimized to const item, see optimize_aggregated_query() in opt_sum.cc
let create_table_sql=CREATE TABLE t1(a INT NOT NULL, PRIMARY KEY(a));
let shardkey=a;
--source include/create_spider_table.inc
INSERT INTO t1 VALUES(1),(2);
--let $query = SELECT max(a), max(concat("*", a, "*")) FROM t1;
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc

--disable_testcase BUG#000
# group list can be empty in aggregate access path
let create_table_sql=CREATE TABLE t1(
  id int primary key auto_increment,
  Period smallint(4) unsigned zerofill DEFAULT '0000' NOT NULL,
  Varor_period smallint(4) unsigned DEFAULT '0' NOT NULL
);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (Period, Varor_period) VALUES (9410,9412);
--let $query = SELECT 1+1 AS summa FROM t1 GROUP BY summa LIMIT 1
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc
--enable_testcase

# sum_func arg 1 replaced by a temporary table Item_field, we saved origial arg to orig_args.
let create_table_sql=CREATE TABLE t (
  id int primary key auto_increment,
  `a` varbinary(10) DEFAULT NULL
);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t (a) VALUES(0xFF00F0F0), (NULL), (0xF0F0FF00);
--let $query = SELECT SQL_BUFFER_RESULT HEX(BIT_AND(a)), HEX(BIT_OR(a)), HEX(BIT_XOR(a)) FROM t
--source ../include/explain_and_run.inc
let drop_table_name=t;
--source include/drop_spider_table.inc

--disable_testcase BUG#0000
let create_table_sql=CREATE TABLE t(id int primary key auto_increment, group_id int, a varbinary(10));
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t(group_id, a) VALUES
(1, 0x34567101ABFF00F0F0),
(2, NULL),
(1, 0x34567102ABF0F0F0F0),
(3, 0x34567104ABF0F0F0F0),
(1, 0x34567103ABFF00F0F0),
(5, 0xABCDEF),
(5, 0x123456),
(5, 0x789123),
(1, 0x34567104ABF0F0F0F0),
(4, 0x34567100ABF0F0F0F0),
(4, NULL),
(4, 0x34567101ABFF00F0F0);
--sorted_result
SELECT group_id, HEX(BIT_AND(a)), HEX(BIT_OR(a)), HEX(BIT_XOR(a))
FROM t
GROUP BY group_id;
--sorted_result
SELECT group_id, HEX(BIT_AND(a)), BIT_AND(192), BIT_AND(0x303233), BIT_AND(binary "foo")
FROM t
GROUP BY group_id;

# Issue #1341 save base_ref_items for EXECUTE
PREPARE s1
FROM "SELECT HEX(BIT_AND(a)),HEX(BIT_OR(a)),HEX(BIT_XOR(a)) FROM t WHERE group_id = 5";
EXECUTE s1;
EXECUTE s1;
DEALLOCATE PREPARE s1;

let drop_table_name=t;
--source include/drop_spider_table.inc
--enable_testcase

# access path STREAM could be pushed to workers
let create_table_sql=CREATE TABLE t1(
  id int primary key auto_increment,
  `i` int DEFAULT NULL,
  `d` date DEFAULT NULL
);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (i, d) VALUES (1, '2008-01-01'), (2, '2008-01-02'), (3, '2008-01-03');
 # force filesort
--sorted_result
--let $query = SELECT COALESCE(d, d), IFNULL(d, d), IF(i, d, d), CASE i WHEN i THEN d ELSE d END, GREATEST(d, d), LEAST(d, d) FROM t1 ORDER BY RAND()
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc

let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, c1 INT);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (c1) VALUES(1),(2),(3);
--let $query = (SELECT c1 FROM t1) UNION ALL (SELECT c1 FROM t1) LIMIT 2
--eval EXPLAIN $query
--replace_regex /\d+/N/
--eval $query
let drop_table_name=t1;
--source include/drop_spider_table.inc

--disable_testcase BUG#0000
# Json sum functions support
let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, ckey VARCHAR(8), grp VARCHAR(8), val VARCHAR(8));
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (ckey, grp, val) VALUES ("key1", "g1", "v1"), ("key2", "g1", "v2"), ("key3", "g2", "v3");
--let $query = SELECT JSON_ARRAYAGG(ckey) AS ckeys FROM t1
--source ../include/explain_and_run.inc
--let $query = SELECT grp, JSON_ARRAYAGG(ckey) AS keys_grouped FROM t1 GROUP BY grp
--source ../include/explain_and_run.inc
--let $query = SELECT JSON_OBJECTAGG(ckey, val) AS key_val FROM t1
--source ../include/explain_and_run.inc
--let $query = SELECT grp, JSON_OBJECTAGG(ckey, val) AS key_val_grouped FROM t1 GROUP BY grp
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc
--enable_testcase

# Sort through a temporary table
let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, a INT, b TEXT);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (a, b) VALUES (1, 'hello'), (2, 'world');
--let $query = SELECT 1 FROM t1 ORDER BY concat(uuid(), b) DESC LIMIT 1
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc

--disable_testcase BUG#0000
# Issue #1212 GROUP BY sorting with DISTINCT, wrong save_sum_fields and
# items_to_copy
let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, a INT, b INT);
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (a, b) VALUES(1, 1),(1, 3),(2, 2);
--let $query = SELECT SQL_BIG_RESULT DISTINCT (AVG(a) + 1) AS avg_a  FROM t1 GROUP BY a
--source ../include/explain_and_run.inc
--let $query = SELECT DISTINCT (AVG(a) + 1) AS avg_a, JSON_ARRAYAGG(a) as ja FROM t1 GROUP BY a
--source ../include/explain_and_run.inc
let drop_table_name=t1;
--source include/drop_spider_table.inc
--enable_testcase

# inconsistent reclength between collector table and and worker row sender temptable
let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, a INT, b VARCHAR(20));
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1 (a, b) VALUES(1, 'a'), (2, 'b'), (3, 'c'), (3, 'c'), (4, 'c');
SELECT DISTINCT a FROM t1 GROUP BY b,a ORDER BY 1;
let drop_table_name=t1;
--source include/drop_spider_table.inc

# Issue #1341 save base_ref_items for EXECUTE
let create_table_sql=CREATE TABLE t1(id int primary key auto_increment, track varchar(15));
let shardkey=id;
--source include/create_spider_table.inc
INSERT INTO t1(track) VALUES ('CAD'), ('CAD');
PREPARE STMT FROM
"SELECT 1 FROM t1
  WHERE
        track IN (SELECT track FROM t1
                                    GROUP BY track
                                      HAVING track>='CAD')";
EXECUTE STMT;
EXECUTE STMT;
DEALLOCATE PREPARE STMT;
let drop_table_name=t1;
--source include/drop_spider_table.inc

# make sure pushed_idx_cond is parallel safe
let create_table_sql=CREATE TABLE t2 (id int primary key auto_increment, date_col datetime NOT NULL, col1 int, filler varchar(255), KEY date_col (date_col, col1));
let shardkey=id;
--source include/create_spider_table.inc
EXPLAIN FORMAT=tree select * from t2 force index(date_col) where    col1 + 10000000 > (@cnt:=@cnt+1) and date_col >= date('2014-04-01');
let drop_table_name=t2;
--source include/drop_spider_table.inc

# JOIN is disabled since it is not supported
--disable_testcase BUG#0000
--echo # Don't support dynamic range access
CREATE TABLE t1 (
  c1 INT NOT NULL,
  c2 VARCHAR(1) DEFAULT NULL,
  PRIMARY KEY (c1)
);

CREATE TABLE t2 (
  c1 INT NOT NULL,
  c2 VARCHAR(1) DEFAULT NULL,
  PRIMARY KEY (c1)
);

INSERT INTO t2 VALUES (10,'v');
INSERT INTO t2 VALUES (11,'r');

EXPLAIN FORMAT=tree SELECT t1.c2 FROM t2 STRAIGHT_JOIN t1 ON t1.c1 < t2.c1;

DROP TABLE t1, t2;

--echo # Don't support duplicateweedout semijoin
CREATE TABLE t1 (
  a int DEFAULT NULL,
  b int DEFAULT NULL
);
INSERT INTO t1 VALUES(0, 0), (1, 1), (2, 2);

CREATE TABLE t11 (
  a int DEFAULT NULL,
  b int DEFAULT NULL
);

EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE a IN (SELECT /*+ semijoin(dupsweedout) */ a FROM t11);
--echo # Don't support materialization (lookup) semijoin, yet
EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE a IN (SELECT /*+ semijoin(materialization) */ a FROM t11);

DROP TABLE t1, t11;

# Item_view_ref::first_inner_table clone support
CREATE TABLE t1 (
  i int DEFAULT NULL
);
CREATE TABLE t2 (
  pk int NOT NULL,
  PRIMARY KEY (`pk`)
);

CREATE VIEW v1 AS SELECT pk from t2;

INSERT INTO t1 VALUES(1);
INSERT INTO t2 VALUES(10);

EXPLAIN FORMAT=tree SELECT v1.pk FROM t1 LEFT JOIN v1 ON t1.i = v1.pk  GROUP BY v1.pk;
DROP TABLE t1, t2;
DROP VIEW v1;

# temporary table having is unsafe item
CREATE TABLE t1 (
col_varchar_key varchar(1) DEFAULT NULL,
col_varchar_nokey varchar(1) DEFAULT NULL,
KEY col_varchar_key (col_varchar_key))
;
INSERT INTO t1 VALUES
('v','v'),('r','r');
CREATE TABLE t2 (
col_varchar_key varchar(1) DEFAULT NULL,
col_varchar_nokey varchar(1) DEFAULT NULL,
KEY col_varchar_key(col_varchar_key))
;
INSERT INTO t2 VALUES
('r','r'),('c','c');
CREATE VIEW v3 AS SELECT * FROM t2;

EXPLAIN format=tree SELECT DISTINCT alias2.col_varchar_key
FROM t1 AS alias1 JOIN v3 AS alias2
ON alias2.col_varchar_key = alias1.col_varchar_key
HAVING col_varchar_key IN (SELECT col_varchar_nokey FROM t2);
DROP VIEW v3;
DROP TABLE t1, t2;

CREATE TABLE Country (
  code char(3) DEFAULT NULL,
  continent char(8) DEFAULT NULL,
  KEY (continent)
);

CREATE TABLE City (
  Name varchar(16),
  Country char(3),
  Population bigint,
  KEY (Population)
);
CREATE TABLE Satellite(name varchar(32), country_code char(3), index(country_code));
INSERT INTO Satellite values('Optus D1', 'CHN');

INSERT INTO Country VALUES('CHN', 'Asia'), ('USA', 'American');
INSERT INTO City VALUES('Beijing', 'CHN', 800 * 1000 * 1000);
INSERT INTO City VALUES('New York', 'USA', 1200 * 1000 * 1000);

--echo # Not support semijoin materialization lookup
--let $query = select /*+ semijoin(@q1 materialization) */ * from Country where Country.code IN (select /*+ qb_name(q1) */ City.Country from City where City.Population > 7*1000*1000) and Country.continent='Asia'
--source suite/parallel_query/include/explain_and_run.inc
--echo # Not support semijoin materialization scan
--let $query = select /*+ semijoin(@q1 materialization) JOIN_SUFFIX(Country) */ * from Country where Country.code IN (select /*+ qb_name(q1) */ City.Country from City where City.Population > 7*1000*1000) and Country.continent='Asia'
--source suite/parallel_query/include/explain_and_run.inc

--echo # Not support parallel loose scan
EXPLAIN FORMAT=tree select * from Country where Country.code in (select country_code from Satellite);

DROP TABLE Country, City, Satellite;

--echo # Not support parallel scan in semijoin first match inner tables
CREATE TABLE t1(a INT);
CREATE TABLE t2(a INT);
CREATE TABLE t6(a INT);
INSERT INTO t1 VALUES(1);
INSERT INTO t2 VALUES(5), (8);
INSERT INTO t6 VALUES (7),(1),(0),(5),(1),(4);
EXPLAIN FORMAT=tree SELECT * FROM t2 AS nt2 WHERE 1 IN (SELECT it1.a FROM t1 AS it1 JOIN t6 AS it3 ON it1.a=it3.a);
DROP TABLE t1, t2, t6;
--enable_testcase

# reduce fields for unpushed item
let create_table_sql=CREATE TABLE t1(id INT PRIMARY KEY AUTO_INCREMENT, b INT);
let shardkey=id;
--source include/create_spider_table.inc

SELECT
  ref_0.b AS c2,
  CASE WHEN ref_0.b IS NULL THEN upper(
      cast(reverse(
        cast(cast(NULL AS CHAR) AS CHAR)) AS CHAR)) ELSE upper(
      cast(reverse(
        cast(cast(NULL AS CHAR) AS CHAR)) AS CHAR)) END
     AS c3
FROM
  t1 AS ref_0
WHERE 21 DIV ref_0.b
ORDER BY 1, 2;
let drop_table_name=t1;
--source include/drop_spider_table.inc

# clean env.
--source ../include/deinit_spider.inc
--enable_warnings
